
# JavaScript 简介
> 一个完整的 JavaScript 实现由三部分组成： 核心(ECMAScript)、 文档对象模型(DOM)、浏览器对象模型(BOM)

**ECMAScript**，由 ECMA-262 定义，提供核心语言功能。

**文档对象模型(DOM)** 是针对 XML 但经过扩展用于 HTML 的应用程序接口。把整个页面映射为一个多层次节点。提供访问和操作网页内容的方法和接口。

**浏览器对象模型(BOM)** 控制浏览器显示页面以外部分，提供与浏览器交互的方法和接口。

# 在 HTML 中使用 JavaScript
`<script>元素`有 6 个属性:
- `async` 可选。 表示立即下载脚本，但不应妨碍页面中其他操作，只对外部脚本有效。异步脚本，一定会在页面 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。
- `charset` 可选。指定字符集
- `defer` 可选。表示脚本可以延迟到文档完全解析和显示后再执行。最好只包含一个，因为实际执行顺序不一定。延迟脚本总是按照指定他们的顺序执行。
- `src` 指定执行的外部文件
- `type` 类型。默认`text/javascript`

使用方式有两种: 直接写入代码或引入外部文件。解析顺序是按照出现的先后顺序解析。写入代码中不能出现`<script>`。

`<script>`应该放在`<head>`元素中，目的是把所有外部文件引用都放相同地方，但这样会影响页面加载，为了避免这个问题，现在一般都放到`<body>`元素后.

引入外部文件的优点:
1. 可维护性
2. 可缓存
3. 适应未来

`<noscript>元素`用于不支持 JavaScript 的网页。内包含标签在 JavaScript 不支持的时候会显现。

# 基本概念
所谓标识符，就是指变量、函数、属性的名字，或者函数参数。标识符规则:
1. 第一个字符必须是一个字母、下划线(_) 或一个美元符号($);
2. 其他字符可以是字母、数字、美元符号和下划线
3. 惯例采用驼峰大小写格式，第一个字母小写。
4. 不能把关键字当做标识符

ES5 引入严格模式。`use strice` 使用严格模式

## 变量
ECMAScript 变量时松散的类型，可以用来保存任何类型的数据，每个变量仅仅是一个用于保存值的占位符而已。 使用 `var` 定义变量为作用域的局部变量。未经初始化的变量会保存一个特殊值 undefined。可以修改变量值的同时修改值的类型。

省略 `var` 的话定义的是全局变量，可能会造成命名冲突，不推荐使用。给未经声明的变量赋值在严格模式会报错。严格模式下，不能定义名为 eval 和 arguments 的变量

> ECMAScript 有 5 种基本的数据类型: Undefined、 Null、 Boolean、 Number 和 String。还有 1 种复杂数据类型 Object。 
 
Object 的本质是由一组无序的名值组成。 ES 不支持任何创建自定义类型的数据。

`typeof` 用于检测给定变量的数据类型
- "undefined" 这个值未定义
- "boolean" 这个值是布尔值
- "string" 这个值是字符串
- "number" 这个值是数值
- "object" 这个值是对象或null
- "function" 这个值是函数。

`typeof message` 注意: typeof 是操作符而不是函数。 `typeof null` 返回 "object", 因为 null 被认为是一个空对象的引用。**可以通过 typeof 区分函数和其它对象**。

### Undefined 类型
只有一个值，在 var 声明变量但没初始化时，值为 undefined。 主要目的是用于比较。

注意: 对没有声明和未赋值变量使用 typeof， 仍然返回 undefined。但仍然要显示赋值，可以检测到没有声明的变量。

### Null 类型
null 值表示一个空对象指针。这也是 typeof 检测为 object 的原因。如果定义变量来保存对象，最好赋值为 null，有助于区分 null 和 undefined，这样一来，只要直接检测 null 值就可以知道相应变量是否已经保存了一个对象引用。 `null == undefined` 返回 true

### Boolean 类型
只有两个字面值: true 和 false，区分大小写。转换函数 Boolean()

| 数据类型  |  转换为 true   | 转换为 false |
| :-------- | :------------: | -----------: |
| String    | 任何非空字符串 |     空字符串 |
| Number    |  任何非0数字   |     0 和 NaN |
| Object    |    任何对象    |         null |
| Undefined |     不适用     |    undefined |

if 语句会自动转换变量为 boolean

### Number 类型
使用 IEEE754 格式来表示整数和浮点数值(双精度数值)。最基本数值面字量格式是10进制。八进制第一位必须是0， 八进制在严格模式下无效。 十六进制字面值前两位必须是 0x。

> 保存数值可以保存+0 和 -0， 正零和负零相等。

1. 浮点数值 包含一个小数点，小数点后面至少有一位数字。保存浮点数需要的空间是整数值的两倍。ECMAScript会不失时机将浮点数转化为整数。

    对于极大或极小的数，用e表示。默认情况下，ECMAScript会将小数点后有 6 个零以上的浮点数值转转为以 e 表示法表示的数值。浮点数值最高精度为17位小数，但进行算术计算时其精度远远不如整数。
    ```
    0.1 + 0.2 = 0.30000000000000004
    ```
2. 数值范围 最小数值 `Number.MIN_VALUE` 在大多数浏览器中为 5e-324, 最大数值 `Number.MAX_VALUE`。 超过这个范围会自动转换成特殊的 Infinity 值，可以使用 `isFinite()` 判断是否是极值，在范围之内返回 true
3. NaN (Not a Number) 特殊值，用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会抛出错误)。 任何数值除以 0 都返回 NaN。NaN与任何值都不想等，包括自身。可以通过 `isNaN()` 判断。

    用于判断对象时，调用对象的 valueOf() 方法，确定该方法返回值是否可以转为数值， 如果不能，再调用 toString(),在测试。
4. 数值转换：
   1. Number(), null 返回 0， undefined 返回 NaN
   2. parseInt() 常用，会忽略前面空格，可识别进制，ES5 不能解析八进制，第二个参数为转换时基数
   3. parseFloat() 只解析十进制，忽略前导0
   
### String 类型
表示由零或多个 16 位 Unicode 字符组成的字符序列，即字符串。

1. 字符字面量: 转移序列 `\n`换行、`\xnn`十六进制、`\unnnn`十六进制表示字符等
2. 字符串特点: 字符串不可改变。要改变会销毁原来的
3. 转换字符串: toString(), 但 null 和 undefined没有这个方法。传递参数为数值的基数；String() 可用于 null 和 undefined，返回 "null" 和 "undefined"

### Object 类型
对象是一组数据和功能的集合。通过执行 new 操作符创建。
```
var o = new Object(); // 不推荐省略 ()
```
Object 每个实例都有属性和方法
- constructor： 保存着用于创建当前对象的函数
- hasOwnProperty(propertyName): 检查给定属性是否在对象中
- isPrototypeOf(object) 检查传入对象是否是对象原型
- propertyInEnumerable(propertyName): 用于检查给定属性是否能够使用 for-in 语句枚举
- toLocaleString() 返回对象字符串表示，字符串与执行环境地区对应
- toString() 和 valueOf() 返回对象字符串、数字或布尔值表示。通常与 toStirng 返回值相同

## 操作符
ECMA-262 描述了一组用于操作数据值的操作符，包括算术运算符、位操作符、关系操作符和相等操作符等。

- 一元操作符: `++` 和 `--`, 还有 `+=`、`-=`
- 位操作符: 按内存中表示数值的位来操作数。负数使用二进制补码(绝对值取反加一)保存。
  - 按位非(NOT),由一个波浪线 `~` 表示。等价于操作数的复制减1，速度快
  - 按位与(AND),本质上将数值每一位对齐 `&`
  - 按位或(OR) `|`
  - 按位异或(XOR) `^`
  - 左移 `<<` 右移 `>>`
  - 无符号右移 `>>>` 
-  布尔操作符
   -  逻辑非 `!`
   -  逻辑与 &&
   -  逻辑或 ||
-  乘性操作符 会先用 Number() 转换，后计算
-  加性操作符
-  关系操作符 比较的是两个字符串中对应位置的每个字符编码值。经过一番比较之后，再返回布尔值。
-  相等操作符
   -  `==` 会先转换操作数 强制类型
   - `===` 不会转换操作数 推荐使用
-  条件操作符 `a ? b : c`

## 语句
流程控制语句。

- if语句
    ```js
    if (condition) statement1 else statement2
    ```
- 循环语句
    ```js
    do {
        statement
    } while(expression)
    while(express) statement
    for(initialization; expression; post-loop-express) statement
    // ES 常用语句
    for(property in expression) statement
    ```
    如果表示要迭代的对象变量值为 null 或 undefined, for-in 语句会抛出错误。ES5 会停止循环，保证兼容性
- label语句 代码中添加标签 `label: statement`,可以由 break 或 continue 语句引用。
- break 语句 停止循环； continue 进行下个循环
- with 语句 `with (expression statement` 将代码的作用域设置到一个特定对象中。目的主要为了简化多次编写同一个对象工作，会导致性能下降和调式代码困难，不推荐使用
- switch 语句 条件语句另一类型

## 函数
函数可以封装任意多语句，在任何地方任何时候执行调用。
```js
function functionName(arg0, arg1, ..., argN) {
    statements
}
```
return后语句不会执行，严格模式函数名不能为 `eval` 或 `arguments`, 参数不能为 `eval` 或`arguments`，不能出现两个命名参数同名情况。 

ES 参数跟类型不管，什么都可以传，数量也没有要求，因为参数内部是用一个数组来表示。函数接收到的是数组。 通过 `arguments` 来访问传递的参数。 `arguments`只于数组类似，但不是数组，属于类数组。函数的命名的参数只提供变量，则不是必需的，因为参数可以通过 `arguments` 访问，所有不命名也没关系。

通过访问 `arguments` 对象的`length` 属性，知道多少个参数传递入函数。没有接收传递值的命名参数将自动被赋予 `undefined` 值。所有参数都是值，不能通过引用传递脚本。 严格模式对 `arguments` 进行了限制，不能对 `arguments` 赋值，重写 `arguments` 也会出错。

ES 函数没有重载

# 变量、作用域和内存问题
数据类型分:
- 基本类型 简单数据段 Undefined、 Null、 Boolean、Number、 String 按值访问。 复制变量的时候，是创建一个新的值，赋值到新的变量上，两者操作不影响。
- 引用类型值 可能由多个值构成的对象， JS 不能直接操作内存空间，操作的是引用。复制是把引用复制给新的变量，两个变量都指向同一对象。

ES 所有函数参数都是按值传递的。把函数外部的值复制给函数内部的参数，就是把值从一个变量复杂到另一变量一样。引用类型复制的引用类型的地址，所有函数内引用类型的变化会影响到函数外的变量

## 检测类型
`typeof` 操作符是确定一个变量时字符串、数值、布尔值、还是 `undefined` 的最佳工具。如果变量的值是一个对象或 `null`， 则 `typeof` 操作符会返回 `object`.

对于引用类型的数据， 使用 `instanceof` 操作符
```
result = variable instanceof constructor
```
所有引用类型值都是 object 实例。如果用 `instance` 检查基本类型会返回 false

> `typeof` 检查函数会返回 `function`。 ECMA-262 规定任何在内部实现`[[call]]` 方法对象都应该应用 `typeof` 返回 `function`。Safari 5和 chrome 7 之前检测正则表达式返回 `function`

## 执行环境
执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的**变量对象(variable object)**,环境中定义的所有变量和函数都保存在这个对象中。解析器在处理数据会在后台使用它。

全局执行环境是最外围的一个执行环境。 Web 浏览器，全局执行环境是 window 对象，会在应用退出时销毁。每个函数都有自己的**执行环境**。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。

当代码在一个环境中执行时，会创建变量对象的一个**作用域链(scope chain)**,用途是保证对执行环境有权访问的所有变量和函数的有序访问，前端始终是当前执行代码所在环境的变量对象。

如果这个环境是函数，则将其**活动对象(activation object)** 作为变量对象，活动对象最开始时只包含一个变量，即 `arguments` 对象(这个对象在全局不存在)。作用域链汇中的下一个变量来自包含(外部)环境,再下个变量再下个包含的环境，一直持续到全局执行环境。标识符解析是沿着作用域链一级一级地搜索标识符的过程。

> 内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。 函数参数也被当做变量来对待。

### 延长作用域链
执行环境的类型总共有两种—— 全局和局部(函数),因为有些语句可以在作用域链前端临时增加一个变量对象，该变量会在代码执行后被移除。延长作用域的语句
- `try-catch` 语句的 `catch` 语句,会创建一个新的变量对象，其中包含抛出的错误声明
- `with` 语句,指定对象添加到作用域链

### 没有块级作用域
JS 的 if 语句和 for 语句中 的变量在语句执行完毕之后仍会存在执行环境中。

1. 声明变量: `var` 声明变量自动添加到最接近的环境中。`with` 语句最接近的是函数环境。如果没有使用 `var` 声明变量，该变量会添加到全局环境。
   > 在严格模式下，初始化未经声明的变量会导致错误
2. 查询标识符: 搜索过程从作用域链的前端开始，向上逐级查询，如果找到，就停止搜索，如果在全局环境中没找到，意味着变量没有声明。
   > 变量查询也不是没有代价，访问局部变量比全局变量更快。但 JS 引擎在优化标识符方面做得不错，这些差别可以忽略不计。

## 垃圾收集
js 具有自动垃圾收集机制，执行环境会复制管理代码执行过程中使用的内存。实现原理: 找到那些不再继续使用的变量，然后释放其占用的内存。垃圾收集器会按照固定的时间间隔(或代码执行中预定的收集时间)，周期性地执行这一操作。

局部变量生命周期: 局部变量只在函数执行过程中存在。在这过程，局部变量在栈(或堆)内存上分配相应空间，以便存储它们的值。直到函数执行结束，就可以释放局部变量。垃圾收集器会对不用的变量打上标记，以备将来收回其占用内存。标记无用变量策略因实现而异，通过有两种策略:
1. **标记清除(mark-and-sweep)**: 最常用。当变量进入环境时，标记为"进入环境"，离开环境时标记为"离开环境"。可以用任何方式标记变量。垃圾收集器在运行时会给存储内存中所有变量加上标记。去掉环境中变量以及被环境中变量引用变量的标记，被加上标记的变量将被视为准备删除的变量，因为环境中的变量无法访问到这些变量。最后，完成**内存清除**工作，销毁带标记的值并回收内存空间。
2. **引用计数(reference counting)**:不太常见。跟踪记录每个值被引用的次数。声明一个变量并将引用类型值赋给变量时，值引用次数为1，如果值被赋给另一个变量，引用次数加1。相反减1。但值引用次数为0时，就可以回收该值。当垃圾收集器下次再运行时，就会释放引用次数为零的值所占的内存。
   
    严重的问题: **循环引用**: 对象A中包含一个指向对象B的指针，而对象B中包含一个指向对象A的引用。IE 的 DOM 和 BOM 是使用 C++ 以 COM(组件对象模型) 对象形式实现的，COM 垃圾收集机制采用的是引用计数策略。IE 中涉及 COM 对象，会存在循环引用问题。IE9 把 BOM 和 DOM 对象都转换为真正的 JS 对象，避免两种垃圾收集算法并存导致问题。
3. **性能问题**: 垃圾收集器时周期运行的，如果变量分配内存数量很客观，那么回收工作量也相当大。
    
    IE6 垃圾收集器时根据内存分配量运行的，比如 256个变量、64KB字符串等。达到上述临界值，垃圾收集机制就会运行。问题是一个脚本固定变量接近临界值时，会触发频繁的垃圾回收，影响性能。

    IE7 触发垃圾收集的变量分配、字面量或数组元素临界值被调整为动态修正。如果垃圾收集例程的内存分量低于 15%,则变量、字面量和数组元素临界值就会加倍。如果回收了 85% 的内存分量，各种临界值重置回默认值。
    > IE中 `window.CollectGarbage()` 和 opera7及更高 `window.opera.collect()` 启动垃圾收集例程，不推荐使用
4. **管理内存**: 分配给 Web 浏览器的可用内存数量通常要比分配给桌面应用程序的少。目的主要是出于安全方面考虑，防止运行 JS 网页耗尽全部系统内存导致系统奔溃。影响栈和线程同时执行语句数量。

    优化内存占用最近方式时为执行中代码保存必要的数据。**解除引用(dereferencing)**: 一旦数据不再有用，最好通过将其设置为 null 来释放引用。作用是让值脱离执行环境，以便垃圾收集器下次运行将其回收。

# 引用类型
**引用类型**是一种数据结构，用于将数据和功能组织在一起。常被称为**类**。引用类型有时候也被称为 **对象定义**。

对象是某个特定引用类型的**实例**。新对象使用 `new` 操作符跟一个**构造函数**来创建。

## Object 类型
Object 是 ES 中使用最多的一个类型。是理想的数据存储和发送方式。创建方式有两种:
1. 使用 `new` 创建：
    ```js
    var person = new Object();
    person.name = 'Tom';
    ```
2. 使用**对象字面量**表示法。对象定义的简写形式，目的是简化创建包含大量属性对象的过程。
    ```js
    var person = {
        name: 'Tom'
    }
    ```

    左花括号({) 表示对象字面量的开始，因为它出现了**表达式上下文(express context)** 中。 ES 中表达式上下文指的是能够返回一个值(表达式)。赋值操作符表示后面时一个值。
    
在对象字面量中，使用逗号来分割不同属性，但在最后一个属性后不要加逗号，否则在 IE7及更早版本和 Opera 中导致错误。

> 在通过对象字面定义对象时，实际上不会调用 Object 构造函数(Firefox2及更正版本会调用)

对象字面量也是向函数传递大量可选参数的首选方式。适合需要向函数传入大量参数的场合。一般来说，访问对象属性使用点表示法`.` ,不过在 JS 中也可以使用方括号表示法来访问对象属性，访问属性要以字符串形式放到方括号中。方括号有点是可以使用变量来访问属性
```js
var propertyName = 'name';
person[propertyName] = 'Tom';
```
如果属性名包含错误语法字符，或属性名使用的是关键字或保留字，也可以使用方括号法，如`person["first name"]`。通常建议使用点表示法。

## Array 类型
ES 中数组是有序列表，每一项可以保存任何类型数据。而且大小可以动态调整。
创建方式有两种:
1. 使用 Array 构造函数
    ```js
    var colors = new Array();
    var colors = new Array(20); // 指定长度
    var colors = new Array('red'); // 传入数据，可以多个
    var colors = Array(); // 可省略 new
    ```
2. 创建数组第二种基本方式时使用数组字面量表示法
    ```js
    var colors = ["green", "blue"];
    var names = [];
    var values = [1, 2,]; // 不要这样，会创建一个包含 2或3项的数组
    ```
    不要采用第三种方式的原因是 IE8及之前的版本中 ES 实现数组在数组字面量方面存在 bug，会有3个数据，最后一个为 undefined。所以不推荐使用。

    > 与对象一样，使用数组字面量表示法也不会调用 Array 构造函数

数组索引从 0 开始。数组的项数都保存在 length 属性中。可通过设置 length 来从数组末尾移除项或向数组中添加新项，新项值为undefined。也可向末尾添加数据`colors[colors.length] = "black";`

> 数组最多可以包含 4294967295 个项。

### 检查数组:
    ```js
    if (value instanceof Array) {
        // 对数组执行某些操作
    }
    ```
    `instanceof` 的问题在于它假定只有一个全局执行环境。如果页面中包含多个框架，就存在两个以上不同全局执行环境，从而存在两个以上不同版本的 Array 构造函数。`instanceof` 不能区分不同框架的 array。

    ES5 新增了 `Array.isArray()` 方法来判断是否是数组，不管它在那个执行环境中创建。
### 转换方法: 
所有对象都有 `toLocaleString()`、`toString()`、`valueOf()` 方法。调用数组的 `toString()` 方法返回由数组每个值的字符串拼接而成一个以逗号分隔的字符串。而调用 `valueOf()` 返回的还是数组。
 
当调用数组的 `toLocaleString()` 方法时，它也会创建一个数组值的以逗号分隔的字符串。与前两个方法唯一不同之处在于，这一次为了取得每一项的值，调用的是每一项的 `toLocaleString()` 方法

使用 `join()` 方法，只接受一个参数，指定分隔符，然后将每个数组元素按照分隔符拼接成字符串

> 如果数组某项是 undefined或null， 在4中转化方法中以空字符串表示
###  栈方法: 
栈是一种 LIFO 的数据结构。往栈中推入和弹出数据，对应数组的`push()`(返回修改后数组长度,可同时推入多项数据，用逗号分隔) 和 `pop()`(返回弹出的项)
6. 队列方法: 队列数据结构访问规则是 FIFO(先进先出).在队里末端添加数据，队列前端删除数据，对应数组的`push()` 和 `shift()`。 ES 还提供 `unshift()` 函数来向数组头部添加数据。使用 `unshift()` 和 `pop()` 方法来从相反反向模拟队列。

    > IE7及更早版本 `unshift()` 总返回 `undefined`

###  重排列方法: 
`reverse()` 和 `sort()` 。sort方法默认升序排序，会调用每个数组项的 toString() 转型方法，然后比较得到字符串，以确定排序。接收一个比较函数作为参数。比较函数接收两个值，如果第1个参数位于第2个参数前，返回负数，相等放回0， 之后返回正数。
    `(a, b) => a - b`
    > `reverse()` 和 `sort()` 方法的返回值是经过排序之后的数组。

###  操作方法
- `concat()` 基于当前数组中所有项建立一个新数组
- `slice()` 中数组中截取元素组成新数组,接受2个参数，开始位置和结束位置，返回新数组。传入负数，用数组长度加负数得到位置。
- `splice()` 删除任意数量的项，指定2个参数，要删除位置和删除项数
  - 插入数据 `splice()` 指定3个参数，起始位置，删除项数，插入数据
  - 替换 `splice(2, 1, "red")`
  - splice 始终返回一个数组。
- 位置方法: ES5 新增 `indexOf()` 和 `lastIndexOf()` 接收两个参数，要查找的项和查找起点位置。一个从头往后找，一个从后往前找。返回要查找项在数组中位置，没有返回 -1.
- 迭代方法

# 面向对象的程序设计
# 函数表达式
# BOM
# 客户端检测
# DOM
# DOM 扩展
# DOM2 和 DOM3
# 事件
# 使用 Canvas 绘图
# HTML5 脚本编程
# 错误处理与调试
# E4X
# JSON
# Ajax 与 Comet
# 高级技巧
# 离线应用与客户端存储
# 最佳实践
# 新兴的 API 